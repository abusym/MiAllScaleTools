# MiAllScaleTools 开发文档

## 目标与背景

本项目用于将**电子秤配套软件目录**内的 **SQLite 数据库**商品数据，按约定规则同步到 **MiAll 收银软件的 SQL Server 数据库**中，达到“秤端商品/价格变化 → 收银端自动更新”的效果。

参考旧实现（`MiAllScaleTools/old source code`）的既有业务规则：

- **秤端读取**：读取商品名称、价格、条码；条码要求为 **7 位**，并取其中 **第 3-7 位（5 位）**作为 MiAll 条码（旧代码：`mcode.Substring(2,5)`）。
- **MiAll 侧写入**：以商品类目 **`099 生鲜（电子秤）`** 为隔离维度，按 `barcode + goodstypeno` **先 update，0 行则 insert**。

> 说明：旧代码的数据源为 Access（`mscale.mdb`），新项目的数据源为 SQLite。业务规则可复用，数据读取层需要替换。

旧代码存档见：`docs/旧代码参考.md`

## 范围（Scope）

### 本期必须实现

- 从 SQLite 读取秤端商品列表（名称/价格/条码）。
- 将商品同步到 MiAll（SQL Server）中：
  - 已存在则更新：价格、名称
  - 不存在则新增：生成新的 `goodsno` 并插入到 `jbgoods`
- 提供可执行的 WPF 工具（WinExe，.NET 6 WPF）：
  - 支持配置数据库路径/连接字符串
  - 一键执行同步，并显示进度与结果摘要

### 暂不强制（可选）

- “删除 MiAll 中不存在于秤端的商品”（谨慎：可能误删）
- 增量同步（按更新时间/变更标记）
- 计划任务/后台服务化

## 术语

- **秤端库（Scale DB）**：电子秤软件目录下的 SQLite 数据库文件。
- **MiAll DB**：MiAll 收银软件使用的 SQL Server 数据库（例如旧实现为 `MiDe5`）。
- **电子秤类目**：MiAll 中用于承载秤端商品的商品类目，旧实现固定名为 `099 生鲜（电子秤）`。

## 系统架构与模块划分

建议采用分层结构（便于测试与替换数据源）：

- **UI 层（WPF）**
  - 配置输入：SQLite 路径、SQL Server 连接串、类目名、条码规则等
  - 执行按钮：启动同步任务
  - 展示：进度条、当前商品、成功/失败数量、日志
- **应用层（Sync Orchestrator）**
  - `IScaleGoodsReader`：读取秤端商品（SQLite）
  - `IMiAllGoodsRepository`：查询/写入 MiAll（SQL Server）
  - `ISyncService`：实现同步策略（upsert、校验、可选删除）
- **基础设施层（Infrastructure）**
  - SQLite 访问：`Microsoft.Data.Sqlite`（建议）
  - SQL Server 访问：`Microsoft.Data.SqlClient` 或 `System.Data.SqlClient`
  - 日志：建议 `Serilog`（写文件 + UI 展示）

## 数据契约（Domain Model）

统一内部模型（建议与旧代码一致）：

- `Good`
  - `Name`：string（商品名称）
  - `Barcode`：string（同步到 MiAll 的条码；通常为 5 位）
  - `Price`：decimal（价格；注意精度）

> 旧代码使用 `double`，新实现建议用 `decimal`，避免货币精度问题。

## 数据源：电子秤 SQLite

### 设计原则（不依赖具体表结构）

本项目**不要求完全掌握电子秤 SQLite 表结构**。只要能够通过一条查询 SQL 读取到同步所需的关键数据即可：

- `name`：商品名称
- `price`：商品价格
- `barcode`：秤端条码（旧规则：7 位）

因此读取 SQL 采用**配置驱动**方式：你只需要在配置文件里写入一条可用的查询语句，并确保返回列名（或别名）为 `name/price/barcode`。

### SQLite 路径（固定目录，写入配置并保存）

电子秤软件的 SQLite 数据库存在于某个固定目录，本工具通过配置项指定并可在 UI 中修改保存：

- `ScaleDbPath`：SQLite 数据库文件完整路径（例如：`D:\ScaleApp\data\scale.db`）

### 读取 SQL（配置驱动）

- `ScaleGoodsQuery`：读取商品 SQL（要求输出列：`name`, `price`, `barcode`）

示例（仅示意，实际以你现场可跑通的 SQL 为准）：

- `SELECT 商品名字段 AS name, 价格字段 AS price, 条码字段 AS barcode FROM 商品表;`

并在代码里对条码执行规则校验与转换（见“条码规则”）。

### 条码规则（沿用旧实现，默认）

- 输入条码必须为 **7 位**
- 取 **第 3-7 位**作为同步条码（即 `Substring(2, 5)`）

建议配置化：

- `BarcodeLengthExpected`：7
- `BarcodeExtractStart`：2
- `BarcodeExtractLength`：5

## 目标库：MiAll（SQL Server）

### 旧实现涉及表（推断/沿用）

旧代码对 MiAll DB 的依赖如下：

- 表：`jbgoodstype`
  - 字段：`goodstypeno`、`goodstypename`
  - 用途：通过 `goodstypename='099 生鲜（电子秤）'` 获取 `goodstypeno`
- 表：`jbgoods`
  - 字段：`goodsno`、`goodscode`、`goodsname`、`goodstypeno`、`barcode`、`srefprice`、`salestype`
  - upsert 条件：`barcode='{barcode}' AND goodstypeno='{goodstypeno}'`

> 若你当前 MiAll 版本库表/字段不一致，需要提供实际表结构（或截图/脱敏脚本）以调整。

### 商品类目（Good Type）

默认类目名：`099 生鲜（电子秤）`

同步前置条件：

- MiAll 后台必须存在该类目；否则应提示用户创建

建议配置项：

- `MiAllScaleGoodsTypeName`：默认 `099 生鲜（电子秤）`

### Upsert 规则（必须）

对每个秤端商品：

1. 查 `goodstypeno`（通过类目名）
2. 执行更新：
   - `UPDATE jbgoods SET srefprice=@price, goodsname=@name WHERE barcode=@barcode AND goodstypeno=@goodstypeno`
3. 若更新影响行为 0，则插入：
   - 生成 `goodsno`：旧实现为 `SELECT MAX(CAST(goodsno as int))+1 FROM jbgoods`
   - 插入 `jbgoods(...) VALUES(...)`

#### 并发与主键生成风险

旧做法 `max+1` 存在并发冲突风险。若该工具可能被多人/多台同时运行，建议升级为：

- 优先使用数据库端序列/自增（若表结构支持）
- 或使用事务 + 锁（`SERIALIZABLE` / `UPDLOCK, HOLDLOCK`）保护 `max+1`

本期如先按旧逻辑实现，应至少：

- 放在同一连接同一事务内
- 报错时给出明确提示（可能是并发/重复键）

### 删除策略（可选，谨慎）

旧代码存在一个 `DeleteNoExistsProducts` 方法，但其 SQL 实际是：

- `delete jbgoods where goodstypeno=... and barcode in (...)`

这与方法名“删除不存在的商品”语义不一致（更像是“删除这些条码对应的商品”）。因此新项目建议：

- **默认不启用删除**
- 若要做“MiAll 删除秤端已移除商品”，需明确策略：
  - 计算集合差：`MiAll(类目内条码集合) - Scale(条码集合)`
  - 仅删除差集，并提供 **DryRun 预览** + 二次确认
  - 全量删除风险较大（秤端库异常/空表会导致误删），需要保护开关：
    - `ScaleEmptyTreatAsError=true`（秤端读到 0 条直接报错，不执行删除）

## 配置设计

建议采用 `appsettings.json`（或 WPF Settings / registry）承载配置，并在 UI 中可编辑保存。

### 必要配置

- **ScaleDbPath**：秤端 SQLite 文件路径（固定目录下的文件路径，支持保存）
- **ScaleGoodsQuery**：读取商品 SQL（输出列别名必须为：`name`, `price`, `barcode`）
- **SqlServerConnectionString**：MiAll SQL Server 连接字符串（规则与旧实现保持一致，但需可配置）
- **MiAllScaleGoodsTypeName**：类目名（默认 `099 生鲜（电子秤）`）

### 推荐配置

- **BarcodeLengthExpected**：默认 `7`
- **BarcodeExtractStart**：默认 `2`
- **BarcodeExtractLength**：默认 `5`
- **EnableDeleteMissing**：默认 `false`
- **DryRun**：默认 `false`（true 时只预览差异不落库）
- **CommandTimeoutSeconds**：默认 `30`
- **LogFilePath**：默认 `logs\app.log`

## 同步流程（业务流程）

### 主流程

1. 校验配置（文件存在、连接串可连接、SQL 可执行）
2. 从 SQLite 读取商品列表
3. 数据校验与清洗
   - 名称非空
   - 价格为非负
   - 条码符合规则并转换为 MiAll 条码
4. 连接 SQL Server
5. 获取/校验 `goodstypeno`
6. 对每个商品执行 upsert（建议参数化 SQL，避免注入/引号问题）
7. 输出结果摘要（总数、更新数、新增数、失败数）
8. （可选）执行“删除差集”，并输出删除数

### 失败处理与可恢复性

- 单条商品失败：
  - 默认继续后续商品（记录失败列表）
  - UI 展示失败原因（条码不合法 / SQL 异常等）
- 全局失败（无法连接 DB / 读取 SQL 失败）：
  - 直接终止，并提示用户检查配置

## UI 设计（WPF）

建议界面元素：

- **配置区**
  - SQLite 文件选择（Browse）
  - SQL Server 连接字符串输入
  - 类目名输入
  - 条码规则（默认隐藏在“高级”）
- **预览区（可选）**
  - 显示读取到的前 N 条商品（名称/条码/价格）
- **执行区**
  - “测试连接”（SQLite / SQL Server）
  - “开始同步”
  - 进度条 + 当前处理商品
  - 结果摘要（更新/新增/失败）
- **日志区**
  - 滚动日志输出
  - 导出日志文件

## 日志与审计

建议日志至少包含：

- 启动信息（版本、配置摘要：隐藏敏感信息）
- 读取到的商品数量
- 每条商品的 upsert 结果（建议可配置为 Debug 级别，避免日志过大）
- 异常堆栈
- 结果汇总

## 安全性

- **SQL 必须参数化**：避免商品名包含引号导致 SQL 语法错误/注入风险（旧代码为字符串拼接，应修正）
- 连接字符串敏感信息处理：UI 展示可做掩码；日志不可输出密码明文

## 依赖与技术选型

- .NET：`net6.0-windows`（WPF）
- SQLite：建议 `Microsoft.Data.Sqlite`
- SQL Server：建议 `Microsoft.Data.SqlClient`
- 日志：建议 `Serilog`（`Serilog.Sinks.File`）

## 部署与运行

### 运行前检查清单

- 已安装/可访问 SQL Server（与 MiAll 同机或可网络访问）
- MiAll 数据库账号具备对 `jbgoods/jbgoodstype` 的查询与写入权限
- MiAll 后台已创建类目：`099 生鲜（电子秤）`（或与配置一致）
- 获取到秤端 SQLite 文件路径，并确认未被占用（只读一般可并发）

### 发布建议

- 使用 `dotnet publish -c Release` 生成单机可运行包
- 日志写入 `logs\`，确保有写权限

## 测试策略

### 单元测试（建议）

- 条码转换与校验（7 位 → 截取 5 位；异常分支）
- 映射与清洗（空名称、负价格、空条码）

### 集成测试（建议）

- 使用测试库（SQL Server 测试库）验证 upsert 行为
- 使用一份样例 SQLite 库验证读取 SQL 和字段映射

## 需要你补充/确认的信息（用于写默认配置，可不影响实现）

你已确认“规则保持一致、SQLite 表结构不必写死、连接字符串保持一致但可配置”。为了我能给出一套**可直接运行的默认配置**，仍建议你补充以下任一项：

1. 一条现场可用的 `ScaleGoodsQuery`（能返回 `name/price/barcode`）
2. SQLite 数据库文件默认路径（`ScaleDbPath`）
3. MiAll 数据库名（默认是否为 `MiDe5`）



